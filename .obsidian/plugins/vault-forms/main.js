/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian15 = require("obsidian");

// src/form-field/form-field.constants.ts
var FORM_FIELD_ELEMENT_TYPE = /* @__PURE__ */ ((FORM_FIELD_ELEMENT_TYPE2) => {
  FORM_FIELD_ELEMENT_TYPE2["TEXT"] = "text";
  FORM_FIELD_ELEMENT_TYPE2["DATE"] = "date";
  FORM_FIELD_ELEMENT_TYPE2["TIME"] = "time";
  FORM_FIELD_ELEMENT_TYPE2["DROPDOWN"] = "dropdown";
  FORM_FIELD_ELEMENT_TYPE2["NUMBER"] = "number";
  FORM_FIELD_ELEMENT_TYPE2["TOGGLE"] = "toggle";
  FORM_FIELD_ELEMENT_TYPE2["RANGE"] = "range";
  FORM_FIELD_ELEMENT_TYPE2["TEXTAREA"] = "textarea";
  return FORM_FIELD_ELEMENT_TYPE2;
})(FORM_FIELD_ELEMENT_TYPE || {});

// utils.ts
function fromFormDataToFormField(formData) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  const formDataMap = /* @__PURE__ */ new Map();
  formData.map(
    (fieldData) => formDataMap.set(fieldData.className, fieldData)
  );
  const buildExpressionProperty = (expression) => ({
    value: void 0,
    expressionParams: { expression }
  });
  const formField = {
    type: (_a = formDataMap.get("field-type")) == null ? void 0 : _a.fieldValue,
    name: (_b = formDataMap.get("field-name")) == null ? void 0 : _b.fieldValue,
    className: (_c = formDataMap.get("field-class-name")) == null ? void 0 : _c.fieldValue,
    description: buildExpressionProperty(
      (_d = formDataMap.get("field-description")) == null ? void 0 : _d.fieldValue
    ),
    placeholder: buildExpressionProperty(
      (_e = formDataMap.get("field-placeholder")) == null ? void 0 : _e.fieldValue
    ),
    hideExpression: buildExpressionProperty(
      (_f = formDataMap.get("field-hide-expression")) == null ? void 0 : _f.fieldValue
    ),
    content: buildExpressionProperty(
      (_g = formDataMap.get("field-default-value")) == null ? void 0 : _g.fieldValue
    ),
    required: formDataMap.get("field-required").fieldValue === "true",
    writeToOutputNote: ((_h = formDataMap.get("field-write-to-output-note")) == null ? void 0 : _h.fieldValue) === "true"
  };
  if (formField.type === "dropdown" /* DROPDOWN */)
    formField.options = buildExpressionProperty(
      (_i = formDataMap.get("field-dropdown-options")) == null ? void 0 : _i.fieldValue
    );
  if (formField.type === "range" /* RANGE */) {
    formField.minLimit = buildExpressionProperty(
      (_j = formDataMap.get("field-min")) == null ? void 0 : _j.fieldValue
    );
    formField.maxLimit = buildExpressionProperty(
      (_k = formDataMap.get("field-max")) == null ? void 0 : _k.fieldValue
    );
    formField.step = buildExpressionProperty(
      (_l = formDataMap.get("field-step")) == null ? void 0 : _l.fieldValue
    );
  }
  return formField;
}
function getDataAsFrontmatter(data) {
  let frontmatterString = "";
  data.map((formData) => {
    var _a;
    const stringValue = formData.fieldType === "dropdown" /* DROPDOWN */ || formData.fieldType === "text" /* TEXT */ || formData.fieldType === "textarea" /* TEXTAREA */ ? `"${(_a = formData == null ? void 0 : formData.fieldValue) != null ? _a : ""}"` : formData == null ? void 0 : formData.fieldValue;
    frontmatterString += `${formData.className}: ${stringValue}
`;
  });
  return `---
${frontmatterString}---`;
}
function getClassNamesFromExpression(expression) {
  const classNameMatcher = new RegExp(/\$\$\.([0-9a-zA-Z-\-]+)/, "g");
  let matches = void 0;
  const formFieldClassNames = [];
  while ((matches = classNameMatcher.exec(expression)) !== null)
    formFieldClassNames.push(matches[1]);
  return formFieldClassNames;
}
function getFilePathsFromExpression(expression) {
  const filePathMatcher = new RegExp(/%%([^%%]*)%%/, "g");
  let matches = void 0;
  const filePaths = [];
  while ((matches = filePathMatcher.exec(expression)) !== null)
    filePaths.push(matches[1]);
  return filePaths;
}
function fromArrayToRecord(array) {
  if (!array)
    return {};
  const record = {};
  array.map((item) => {
    record[item] = item;
  });
  return record;
}
function isInputExpressionSyntaxValid(inputExpression) {
  try {
    new Function(inputExpression);
    return true;
  } catch (_) {
    return false;
  }
}

// src/form-field/time-form-field.factory.ts
var import_obsidian4 = require("obsidian");

// src/form-field/text-form-field.factory.ts
var import_obsidian3 = require("obsidian");

// src/form-field/form-field.factory.ts
var import_obsidian2 = require("obsidian");

// src/utils/expression-evaluator.ts
var import_obsidian = require("obsidian");
var ExpressionEvaluator = class {
  constructor(app, className) {
    this.app = app;
    this.className = className;
  }
  async evaluateExpression(params) {
    if (!(params == null ? void 0 : params.expression))
      return "";
    params.expression = ExpressionEvaluator.minifyExpression(
      params.expression
    );
    const [prefix, expressionToEvaluate, suffix] = params.expression.includes("{{") && params.expression.includes("}}") ? ExpressionEvaluator.splitExpression(params.expression) : [params.expression, "", ""];
    if (!expressionToEvaluate)
      return prefix;
    const parsedExpression = await this.parseExpression(
      expressionToEvaluate,
      params.context
    );
    try {
      const expressionResult = new Function(
        parsedExpression.includes("return") ? parsedExpression : `return ${parsedExpression};`
      )();
      return prefix ? `${prefix}${expressionResult}${suffix != null ? suffix : ""}` : expressionResult;
    } catch (error) {
      new import_obsidian.Notice(`Error on evaluating ${this.className} expression`);
      console.error(error);
      console.error("Expression:", expressionToEvaluate);
      return `${prefix}${suffix != null ? suffix : ""}`;
    }
  }
  async parseExpression(expression, expressionContext) {
    const formFieldClassNames = expressionContext ? getClassNamesFromExpression(expression) : [];
    formFieldClassNames.forEach((formFieldClassName) => {
      var _a, _b, _c, _d, _e, _f;
      const formField = expressionContext == null ? void 0 : expressionContext.find(
        (formField2) => formField2.formField.className === formFieldClassName
      );
      const classNameMatcher = new RegExp(
        `\\$\\$\\.${formField == null ? void 0 : formField.formField.className}`
      );
      const isFilePath = new RegExp(
        `%%.*\\$\\$\\.${formField == null ? void 0 : formField.formField.className}.*%%`,
        "g"
      );
      const valueToReplace = isFilePath.test(expression) ? `${(_c = (_b = (_a = formField == null ? void 0 : formField.formField) == null ? void 0 : _a.content) == null ? void 0 : _b.value) != null ? _c : ""}` : `'${(_f = (_e = (_d = formField == null ? void 0 : formField.formField) == null ? void 0 : _d.content) == null ? void 0 : _e.value) != null ? _f : ""}'`;
      expression = expression.replace(classNameMatcher, valueToReplace);
    });
    const filePaths = getFilePathsFromExpression(expression);
    await Promise.all(
      filePaths.map(async (abstractFilePath) => {
        const abstractFilePathMatcher = /%%.*%%/;
        if (abstractFilePath.endsWith("/")) {
          const folderPath = abstractFilePath.endsWith("/") ? abstractFilePath.slice(0, -1) : abstractFilePath;
          const folder = this.app.vault.getFolderByPath(folderPath);
          if (!folder) {
            new import_obsidian.Notice(`Folder not found at ${folderPath}`);
            return;
          }
          const fileNames = folder == null ? void 0 : folder.children.map(
            (child) => {
              var _a;
              return (_a = child.basename) != null ? _a : child.name;
            }
          );
          expression = expression.replace(
            abstractFilePathMatcher,
            JSON.stringify(fileNames)
          );
          return;
        }
        const [_, fileExtension] = abstractFilePath.split(".");
        if (fileExtension && fileExtension !== "md") {
          new import_obsidian.Notice(
            `Can't handle .${fileExtension} extension, .md expected`
          );
          expression = expression.replace(
            abstractFilePathMatcher,
            ""
          );
          return;
        }
        if (!fileExtension)
          abstractFilePath = `${abstractFilePath}.md`;
        const file = this.app.vault.getFileByPath(abstractFilePath);
        if (!file) {
          new import_obsidian.Notice(`File not found at ${abstractFilePath}`);
          return;
        }
        let fileFrontMatter = "";
        await this.app.fileManager.processFrontMatter(
          file,
          (frontmatter) => fileFrontMatter = frontmatter
        );
        expression = expression.replace(
          abstractFilePathMatcher,
          JSON.stringify(fileFrontMatter)
        );
      })
    );
    return expression;
  }
  static splitExpression(expression) {
    var _a;
    if (!(expression.includes("{{") && expression.includes("}}")))
      return [expression];
    const expressionMatcher = new RegExp(/{{(.*)}}/);
    const expressionToEvaluate = (_a = expressionMatcher.exec(expression)) == null ? void 0 : _a.at(-1);
    const prefix = expression.split("{{")[0];
    const sufix = expression.split("}}")[1];
    return [prefix, expressionToEvaluate != null ? expressionToEvaluate : "", sufix];
  }
  static minifyExpression(expression) {
    return expression.replace(/\s+/g, " ").trim();
  }
};

// src/form-field/form-field.factory.ts
var FormFieldFactory = class {
  constructor(params) {
    this.debounceUpdateFieldTypes = [
      "text" /* TEXT */,
      "number" /* NUMBER */,
      "range" /* RANGE */
    ];
    this.contentEl = params.contentEl;
    this.app = params.app;
    this.formField = params.formField;
    this.baseRequiredValue = this.formField.required;
    this.hideExpressionContext = params == null ? void 0 : params.hideExpressionContext;
    this.expressionEvaluator = new ExpressionEvaluator(this.app, this.formField.className);
    this.formField.state = "created" /* CREATED */;
  }
  set dependents(dependents) {
    this.dependentFields = dependents.map((dependent) => {
      const update = () => {
        dependent.updateField(void 0, this.formField.className);
      };
      return {
        base: dependent,
        update: this.debounceUpdateFieldTypes.includes(
          this.formField.type
        ) ? (0, import_obsidian2.debounce)(update, 400) : update
      };
    });
  }
  async initializeFormField(dependents) {
    var _a;
    this.formField.setting = this.getSetting();
    await this.assignDefaultValue();
    this.hideFormField(
      await this.expressionEvaluator.evaluateExpression(
        (_a = this.formField.hideExpression) == null ? void 0 : _a.expressionParams
      )
    );
    await this.assignFormFieldAttributes();
    this.dependents = dependents;
    this.formField.state = "initialized" /* INITIALIZED */;
  }
  async assignDefaultValue() {
    await this.assignValue();
  }
  async updateField(value, updatedBy) {
    var _a, _b;
    await this.assignValue(value, updatedBy);
    this.hideFormField(
      await this.expressionEvaluator.evaluateExpression(
        (_a = this.formField.hideExpression) == null ? void 0 : _a.expressionParams
      )
    );
    const htmlEl = this.contentEl.querySelector(
      this.getFormFieldHtmlPath()
    );
    if (!htmlEl)
      throw new Error(
        `Can't find ${this.formField.className} html element`
      );
    await this.assignPlaceholder(htmlEl, updatedBy);
    await this.assignDescription(updatedBy);
    await Promise.all(
      (_b = this.dependentFields) == null ? void 0 : _b.map((dependent) => dependent.update())
    );
  }
  async assignFormFieldAttributes() {
    const htmlEl = this.contentEl.querySelector(
      this.getFormFieldHtmlPath()
    );
    if (!htmlEl)
      return;
    htmlEl.setAttribute("type", this.formField.type);
    if (htmlEl)
      await this.assignPlaceholder(htmlEl);
    if (this.formField.description)
      await this.assignDescription();
  }
  async assignDescription(updatedBy) {
    var _a, _b, _c, _d, _e;
    if (!updatedBy && this.formField.state === "initialized" /* INITIALIZED */)
      return;
    let description = (_b = (_a = this.formField.description) == null ? void 0 : _a.value) != null ? _b : "";
    if ((_c = this.formField.description) == null ? void 0 : _c.expressionParams)
      description = await this.expressionEvaluator.evaluateExpression(
        (_d = this.formField.description) == null ? void 0 : _d.expressionParams
      );
    (_e = this.formField.setting) == null ? void 0 : _e.setDesc(description);
  }
  async assignPlaceholder(htmlEl, updatedBy) {
    var _a, _b, _c, _d;
    if (!updatedBy && this.formField.state === "initialized" /* INITIALIZED */)
      return;
    let placeholder = (_b = (_a = this.formField.placeholder) == null ? void 0 : _a.value) != null ? _b : "";
    if ((_c = this.formField.placeholder) == null ? void 0 : _c.expressionParams)
      placeholder = await this.expressionEvaluator.evaluateExpression(
        (_d = this.formField.placeholder) == null ? void 0 : _d.expressionParams
      );
    htmlEl.setAttribute("placeholder", placeholder);
  }
  hideFormField(hide) {
    var _a, _b;
    this.formField.required = hide === true ? false : this.baseRequiredValue;
    const fieldEl = this.contentEl.querySelector(
      this.getFormFieldHtmlPath()
    );
    const displayType = hide ? "none" : "";
    (_b = (_a = fieldEl == null ? void 0 : fieldEl.parentElement) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.setAttr(
      "style",
      `display:${displayType}`
    );
  }
};

// src/form-field/text-form-field.factory.ts
var TextFormFieldFactory = class extends FormFieldFactory {
  constructor(params) {
    super(params);
  }
  getSetting() {
    const setting = new import_obsidian3.Setting(this.contentEl).setName(this.formField.name).setClass(this.formField.className).addText(
      (text) => {
        var _a;
        return text.onChange(this.updateField.bind(this)).setDisabled((_a = this.formField.disable) != null ? _a : false);
      }
    );
    return setting;
  }
  getFormFieldHtmlPath(formField = this.formField) {
    return `div.${formField.className} > div.setting-item-control > input`;
  }
  async assignValue(value, updatedBy) {
    var _a;
    if (!value && updatedBy || !value && this.formField.state === "created" /* CREATED */)
      value = this.formField.bypassValueExpressionEvaluation ? (_a = this.formField.content.expressionParams) == null ? void 0 : _a.expression : await this.expressionEvaluator.evaluateExpression(
        this.formField.content.expressionParams
      );
    if (value === this.formField.content.value)
      return;
    this.value = value != null ? value : "";
  }
  set value(valueToSet) {
    if (typeof valueToSet !== "string")
      valueToSet = JSON.stringify(valueToSet);
    const fieldEl = this.contentEl.querySelector(
      this.getFormFieldHtmlPath()
    );
    if (fieldEl instanceof HTMLInputElement) {
      fieldEl.value = valueToSet;
      this.formField.content["value"] = valueToSet;
    } else
      new import_obsidian3.Notice(
        `Can't find field element: ${this.getFormFieldHtmlPath()}`
      );
  }
};

// src/form-field/time-form-field.factory.ts
var TimeFormFieldFactory = class extends TextFormFieldFactory {
  normalizeToTimeString(input) {
    let dateObj;
    if (input instanceof Date) {
      dateObj = input;
    } else if (typeof input === "number") {
      dateObj = new Date(input);
    } else if (typeof input === "string") {
      let match = input.match(/^(\d{1,2}):(\d{1,2})$/);
      if (match) {
        const hh = match[1].padStart(2, "0");
        const mm = match[2].padStart(2, "0");
        return `${hh}:${mm}`;
      }
      const parsed = Date.parse(input);
      if (!isNaN(parsed)) {
        dateObj = new Date(parsed);
      }
    }
    if (dateObj && !isNaN(dateObj.getTime())) {
      const hh = String(dateObj.getHours()).padStart(2, "0");
      const mm = String(dateObj.getMinutes()).padStart(2, "0");
      return `${hh}:${mm}`;
    }
    return void 0;
  }
  async assignValue(value, updatedBy) {
    let valueToAssign = value ? value : await this.expressionEvaluator.evaluateExpression(this.formField.content.expressionParams);
    if (!valueToAssign)
      return;
    const normalized = this.normalizeToTimeString(valueToAssign);
    if (!normalized) {
      new import_obsidian4.Notice(`Unexpected format for time field`);
      return;
    }
    if (normalized === this.formField.content.value)
      return;
    this.value = normalized;
  }
};

// src/form-field/dropdown-form-field.factory.ts
var import_obsidian5 = require("obsidian");
var DropdownFormFieldFactory = class extends FormFieldFactory {
  constructor(params) {
    super(params);
  }
  getSetting() {
    const options = fromArrayToRecord(this.formField.options.value);
    const setting = new import_obsidian5.Setting(this.contentEl).setName(this.formField.name).setClass(this.formField.className).addDropdown(
      (dropdown) => dropdown.addOptions(options).onChange(this.updateField.bind(this))
    );
    this.assignFormFieldAttributes();
    this.hideFormField(false);
    return setting;
  }
  set value(valueToSet) {
    const fieldEl = this.contentEl.querySelector(
      this.getFormFieldHtmlPath()
    );
    if (fieldEl instanceof HTMLSelectElement) {
      fieldEl.value = valueToSet;
      this.formField.content["value"] = valueToSet;
    } else
      new import_obsidian5.Notice(
        `Can't find field element: ${this.getFormFieldHtmlPath()}`
      );
  }
  getFormFieldHtmlPath(formField = this.formField) {
    return `div.${formField.className} > div.setting-item-control > select`;
  }
  async resolveDropdownOptions(updatedBy = this.formField.className) {
    var _a, _b;
    const expressionToEvaluate = (_b = (_a = this.formField.options) == null ? void 0 : _a.expressionParams) == null ? void 0 : _b.expression;
    if (!expressionToEvaluate || this.formField.state === "initialized" /* INITIALIZED */ && !expressionToEvaluate.includes(updatedBy))
      return;
    const options = await this.expressionEvaluator.evaluateExpression(this.formField.options.expressionParams);
    this.addNewOptions(options, updatedBy, false, true);
  }
  async assignValue(value, updatedBy) {
    var _a, _b;
    await this.resolveDropdownOptions(updatedBy);
    const valueToAssing = value ? value : await this.expressionEvaluator.evaluateExpression(
      this.formField.content.expressionParams
    ) || Object.values((_b = (_a = this.formField.options) == null ? void 0 : _a.value) != null ? _b : {})[0];
    if (valueToAssing === this.formField.content.value || valueToAssing === "")
      return;
    if (this.formField.options.value && !Object.values(this.formField.options.value).includes(valueToAssing))
      this.addNewOptions([valueToAssing], updatedBy, !!updatedBy);
    this.value = valueToAssing;
  }
  addNewOptions(newOptions, updatedBy = this.formField.className, keepOnlyOneByUpdatedField = true, removeOldOptions = false) {
    newOptions = typeof newOptions === "string" ? JSON.parse(newOptions.replace(/'/g, `"`)) : newOptions;
    if (!newOptions.length)
      return;
    const formFieldHtmlPath = this.getFormFieldHtmlPath();
    const fieldEl = this.contentEl.querySelector(
      this.getFormFieldHtmlPath()
    );
    if (!fieldEl)
      return;
    if (removeOldOptions) {
      fieldEl.innerHTML = "";
      this.formField.options.value = newOptions;
    }
    newOptions.forEach((newOption) => {
      var _a;
      const postAddedOption = keepOnlyOneByUpdatedField ? (_a = this.contentEl) == null ? void 0 : _a.querySelector(
        `${formFieldHtmlPath} > option.${updatedBy}`
      ) : void 0;
      if (postAddedOption && keepOnlyOneByUpdatedField)
        fieldEl.removeChild(postAddedOption);
      fieldEl.createEl("option", {
        value: newOption,
        text: newOption
      }).setAttr("class", updatedBy);
      this.formField.options.value = this.formField.options.value ? [...this.formField.options.value, newOption] : [newOption];
    });
  }
};

// src/form.ts
var import_obsidian10 = require("obsidian");

// src/form-field/toggle-form-field.factory.ts
var import_obsidian6 = require("obsidian");
var ToggleFormFieldFactory = class extends FormFieldFactory {
  constructor(params) {
    super(params);
  }
  getSetting() {
    const setting = new import_obsidian6.Setting(this.contentEl).setName(this.formField.name).setClass(this.formField.className).addToggle(
      (toggle) => toggle.onChange(
        (value) => this.updateField.bind(this)(`${value}`)
      )
    );
    return setting;
  }
  getFormFieldHtmlPath() {
    return `div.${this.formField.className} > div.setting-item-control > div`;
  }
  async assignValue(value, updatedBy) {
    var _a, _b;
    if (!value && updatedBy || !value && this.formField.state === "created" /* CREATED */)
      if (this.formField.bypassValueExpressionEvaluation)
        value = (_a = this.formField.content.expressionParams) == null ? void 0 : _a.expression;
      else {
        const expressionResult = await this.expressionEvaluator.evaluateExpression((_b = this.formField.content) == null ? void 0 : _b.expressionParams);
        value = typeof expressionResult === "string" ? this.handleExpressionResult(expressionResult) : `${expressionResult}`;
      }
    if (value === this.formField.content.value)
      return;
    this.value = value != null ? value : "";
  }
  set value(valueToSet) {
    const fieldEl = this.contentEl.querySelector(
      this.getFormFieldHtmlPath()
    );
    if (fieldEl instanceof HTMLDivElement) {
      if (valueToSet.toLocaleLowerCase() === "true")
        fieldEl.addClass("is-enabled");
      else
        fieldEl.removeClass("is-enabled");
      this.formField.content["value"] = valueToSet;
    } else
      new import_obsidian6.Notice(
        `Can't find field element: ${this.getFormFieldHtmlPath()}`
      );
  }
  handleExpressionResult(expressionResult) {
    expressionResult = expressionResult.toLowerCase().trim();
    if (expressionResult === "true" || expressionResult === "false")
      return expressionResult.toLocaleLowerCase().trim();
    else
      return "false";
  }
};

// src/form-field/range-form-field.factory.ts
var import_obsidian7 = require("obsidian");
var RangeFormFieldFactory = class extends FormFieldFactory {
  constructor(params) {
    super(params);
  }
  getSetting() {
    const setting = new import_obsidian7.Setting(this.contentEl).setName(this.formField.name).setClass(this.formField.className).addSlider((slider) => this.sliderComponent = slider);
    this.sliderComponent.setDynamicTooltip().onChange(this.updateField.bind(this));
    return setting;
  }
  async resolveSliderLimits() {
    var _a, _b;
    const min = this.formField.bypassValueExpressionEvaluation ? this.formField.maxLimit.expressionParams : await this.expressionEvaluator.evaluateExpression(
      this.formField.minLimit.expressionParams
    );
    const max = this.formField.bypassValueExpressionEvaluation ? this.formField.maxLimit.expressionParams : await this.expressionEvaluator.evaluateExpression(
      this.formField.maxLimit.expressionParams
    );
    const step = this.formField.bypassValueExpressionEvaluation ? (_a = this.formField.step) == null ? void 0 : _a.expressionParams : await this.expressionEvaluator.evaluateExpression(
      (_b = this.formField.step) == null ? void 0 : _b.expressionParams
    );
    this.sliderComponent.setLimits(min, max, step != null ? step : 1);
  }
  getFormFieldHtmlPath() {
    return `div.${this.formField.className} > div.setting-item-control > input`;
  }
  async assignValue(value, updatedBy) {
    var _a, _b;
    await this.resolveSliderLimits();
    let valueAsString = value == null ? void 0 : value.toString();
    if (!valueAsString && updatedBy || !valueAsString && this.formField.state === "created" /* CREATED */)
      if (this.formField.bypassValueExpressionEvaluation)
        valueAsString = (_a = this.formField.content.expressionParams) == null ? void 0 : _a.expression;
      else {
        const expressionResult = await this.expressionEvaluator.evaluateExpression((_b = this.formField.content) == null ? void 0 : _b.expressionParams);
        valueAsString = expressionResult;
      }
    if (valueAsString === this.formField.content.value)
      return;
    this.value = valueAsString != null ? valueAsString : "";
  }
  set value(valueToSet) {
    const fieldEl = this.contentEl.querySelector(
      this.getFormFieldHtmlPath()
    );
    if (fieldEl instanceof HTMLInputElement) {
      fieldEl.value = valueToSet;
      this.formField.content["value"] = valueToSet;
    } else
      new import_obsidian7.Notice(
        `Can't find field element: ${this.getFormFieldHtmlPath()}`
      );
  }
};

// src/form-field/textarea-form-field.factory.ts
var import_obsidian8 = require("obsidian");
var TextAreaFormFieldFactory = class extends FormFieldFactory {
  constructor(params) {
    super(params);
  }
  getSetting() {
    const setting = new import_obsidian8.Setting(this.contentEl).setName(this.formField.name).setClass(this.formField.className).addTextArea(
      (textArea) => textArea.onChange(this.updateField.bind(this))
    );
    return setting;
  }
  getFormFieldHtmlPath(formField = this.formField) {
    return `div.${formField.className} > div.setting-item-control > textarea`;
  }
  async assignValue(value, updatedBy) {
    var _a, _b;
    if (!value && updatedBy || !value && this.formField.state === "created" /* CREATED */)
      value = this.formField.bypassValueExpressionEvaluation ? (_a = this.formField.content.expressionParams) == null ? void 0 : _a.expression : await this.expressionEvaluator.evaluateExpression(
        (_b = this.formField.content) == null ? void 0 : _b.expressionParams
      );
    if (value === this.formField.content.value)
      return;
    this.value = value != null ? value : "";
  }
  set value(valueToSet) {
    if (typeof valueToSet === "object")
      valueToSet = JSON.stringify(valueToSet);
    const fieldEl = this.contentEl.querySelector(
      this.getFormFieldHtmlPath()
    );
    if (fieldEl instanceof HTMLTextAreaElement) {
      fieldEl.value = valueToSet;
      this.formField.content["value"] = valueToSet;
    } else
      new import_obsidian8.Notice(
        `Can't find textarea element: ${this.getFormFieldHtmlPath()}`
      );
  }
};

// src/form-field/date-form-field.factory.ts
var import_obsidian9 = require("obsidian");
var DateFormFieldFactory = class extends TextFormFieldFactory {
  normalizeToDateString(input) {
    let dateObj;
    if (input instanceof Date) {
      dateObj = input;
    } else if (typeof input === "number") {
      dateObj = new Date(input);
    } else if (typeof input === "string") {
      let match = input.match(/^(\d{4})[-\/](\d{2})[-\/](\d{2})$/);
      if (match) {
        return `${match[1]}-${match[2]}-${match[3]}`;
      }
      match = input.match(/^(\d{2})[-\/](\d{2})[-\/](\d{4})$/);
      if (match) {
        return `${match[3]}-${match[2]}-${match[1]}`;
      }
      const parsed = Date.parse(input);
      if (!isNaN(parsed)) {
        dateObj = new Date(parsed);
      }
    }
    if (dateObj && !isNaN(dateObj.getTime())) {
      const YYYY = dateObj.getFullYear();
      const MM = String(dateObj.getMonth() + 1).padStart(2, "0");
      const DD = String(dateObj.getDate()).padStart(2, "0");
      return `${YYYY}-${MM}-${DD}`;
    }
    return void 0;
  }
  async assignValue(value, updatedBy) {
    let valueToAssign = value ? value : await this.expressionEvaluator.evaluateExpression(this.formField.content.expressionParams);
    if (!valueToAssign)
      return;
    const normalized = this.normalizeToDateString(valueToAssign);
    if (!normalized) {
      new import_obsidian9.Notice(`Unexpected format for date field`);
      return;
    }
    if (normalized === this.formField.content.value)
      return;
    this.value = normalized;
  }
};

// src/form.ts
var Form = class extends import_obsidian10.Modal {
  constructor(app, params) {
    var _a;
    super(app);
    this.formFieldFactories = [];
    this.defaultOnSubmit = async (data) => {
      const frontmatterData = getDataAsFrontmatter(data);
      let fileName = "";
      if (this.outputName) {
        const expressionEvaluator = new ExpressionEvaluator(
          this.app,
          "output name"
        );
        const expressionContext = this.outputName.includes("$$.") ? this.getExpressionContext(this.outputName) : void 0;
        const expressionResult = await expressionEvaluator.evaluateExpression({
          expression: this.outputName,
          context: expressionContext
        });
        fileName = typeof expressionResult === "object" ? JSON.stringify(expressionResult) : expressionResult;
      } else
        fileName = new Date().getTime().toString(36);
      fileName = typeof fileName === "string" ? fileName : JSON.stringify(fileName);
      fileName = fileName.endsWith(".md") ? `${this.path}${fileName}` : `${this.path}${fileName}.md`;
      this.app.vault.create(fileName, frontmatterData);
    };
    this.app = app;
    this.formFields = params.formFields;
    this.title = params.title;
    this.description = params.description;
    this.submitLabel = !!params.submitLabel ? params.submitLabel : "Submit";
    this.onSubmit = (_a = params.onSubmit) != null ? _a : this.defaultOnSubmit;
    this.path = params.path;
    this.outputName = params.outputName;
  }
  onClose() {
    this.setFormDataNull();
  }
  async onOpen() {
    this.contentEl.createEl("h2", { text: this.title });
    if (this.description) {
      this.contentEl.createEl("p", { text: this.description });
    }
    await this.createFormFields();
    new import_obsidian10.Setting(this.contentEl).addButton(
      (button) => button.setButtonText(this.submitLabel).setCta().onClick(this.handleSubmit.bind(this))
    );
  }
  async createFormFields() {
    this.formFields.forEach((formField) => {
      var _a, _b;
      this.populateExpressionPropertyContexts(formField);
      const factoryParams = {
        formField,
        app: this.app,
        contentEl: this.contentEl,
        hideExpressionContext: this.getExpressionContext(
          (_b = (_a = formField == null ? void 0 : formField.hideExpression) == null ? void 0 : _a.expressionParams) == null ? void 0 : _b.expression
        )
      };
      switch (formField.type) {
        case "date" /* DATE */:
          this.formFieldFactories.push(
            new DateFormFieldFactory(factoryParams)
          );
          break;
        case "text" /* TEXT */:
        case "number" /* NUMBER */:
          this.formFieldFactories.push(
            new TextFormFieldFactory(factoryParams)
          );
          break;
        case "time" /* TIME */:
          this.formFieldFactories.push(
            new TimeFormFieldFactory(factoryParams)
          );
          break;
        case "dropdown" /* DROPDOWN */:
          const dropDownField = factoryParams.formField;
          this.formFieldFactories.push(
            new DropdownFormFieldFactory({
              formField: dropDownField,
              app: factoryParams.app,
              contentEl: factoryParams.contentEl,
              hideExpressionContext: factoryParams.hideExpressionContext
            })
          );
          break;
        case "toggle" /* TOGGLE */:
          this.formFieldFactories.push(
            new ToggleFormFieldFactory(factoryParams)
          );
          break;
        case "range" /* RANGE */:
          this.formFieldFactories.push(
            new RangeFormFieldFactory(factoryParams)
          );
          break;
        case "textarea" /* TEXTAREA */:
          this.formFieldFactories.push(
            new TextAreaFormFieldFactory(factoryParams)
          );
          break;
      }
    });
    for (const factory of this.formFieldFactories) {
      await factory.initializeFormField(
        this.getDependentFields(
          factory.formField.className,
          this.formFieldFactories
        )
      );
    }
  }
  getDependentFields(fieldClassName, formFieldFactories) {
    formFieldFactories = formFieldFactories.filter(
      (factory) => factory.formField.className !== fieldClassName
    );
    const hasReference = (exp, fieldClassName2) => {
      var _a, _b, _c;
      return (_c = (_b = (_a = exp == null ? void 0 : exp.expressionParams) == null ? void 0 : _a.expression) == null ? void 0 : _b.includes(
        `$$.${fieldClassName2}`
      )) != null ? _c : false;
    };
    const expressionProperties = [
      (f) => f.content,
      (f) => f.hideExpression,
      (f) => f.placeholder,
      (f) => f.description
    ];
    const dropdownExpressionProperties = [
      (f) => f.options
    ];
    const rangeExpressionProperties = [
      (f) => f.minLimit,
      (f) => f.maxLimit,
      (f) => f.step
    ];
    const dependents = formFieldFactories.filter((factory) => {
      if (factory.formField.type === "dropdown" /* DROPDOWN */)
        expressionProperties.push(...dropdownExpressionProperties);
      if (factory.formField.type === "range" /* RANGE */)
        expressionProperties.push(...rangeExpressionProperties);
      return expressionProperties.some(
        (prop) => hasReference(prop(factory.formField), fieldClassName)
      );
    });
    return dependents;
  }
  populateExpressionPropertyContexts(formField) {
    const populatePropertyExpressionContext = (property) => {
      if (property && typeof property === "object" && "expressionParams" in property && typeof property.expressionParams === "object" && "expression" in property.expressionParams) {
        property.expressionParams.context = this.getExpressionContext(
          property.expressionParams.expression
        );
      }
    };
    const keys = [
      "content",
      "placeholder",
      "description",
      "hideExpression"
    ];
    keys.forEach(
      (key) => populatePropertyExpressionContext(
        formField[key]
      )
    );
    if (formField.type === "dropdown" /* DROPDOWN */)
      populatePropertyExpressionContext(
        formField["options"]
      );
    if (formField.type === "range" /* RANGE */) {
      populatePropertyExpressionContext(
        formField["minLimit"]
      );
      populatePropertyExpressionContext(
        formField["maxLimit"]
      );
      populatePropertyExpressionContext(
        formField["step"]
      );
    }
  }
  getExpressionContext(expression) {
    const expressionContext = [];
    if (!expression)
      return expressionContext;
    const formFieldClassNames = getClassNamesFromExpression(expression);
    formFieldClassNames.forEach((formFieldClassName) => {
      const partialContext = this.formFieldFactories.find(
        (formFieldFactory) => formFieldFactory.formField.className === formFieldClassName
      );
      if (partialContext)
        expressionContext.push(partialContext);
    });
    return expressionContext;
  }
  getData() {
    const data = [];
    this.formFieldFactories.forEach((factory) => {
      if (factory.formField.writeToOutputNote !== false) {
        data.push({
          className: factory.formField.className,
          fieldType: factory.formField.type,
          fieldValue: factory.formField.content.value
        });
      }
    });
    return data;
  }
  getTimestampNamingStrategy() {
    var _a, _b;
    const date = (_a = this.formFieldFactories.find(
      (factory) => factory.formField.className === "date"
    )) == null ? void 0 : _a.formField.content.value;
    const time = (_b = this.formFieldFactories.find(
      (factory) => factory.formField.className === "time"
    )) == null ? void 0 : _b.formField.content.value;
    const expenseTime = new Date(`${date} ${time}`).getTime();
    const currentMilliseconds = new Date().getMilliseconds();
    return (expenseTime + currentMilliseconds).toString(36);
  }
  setFormDataNull() {
    this.formFieldFactories = [];
    this.formFieldFactories.forEach(
      (factory) => factory.formField.content.value = void 0
    );
  }
  handleSubmit() {
    const requiredUnfilledField = this.getRequiredUnfilledField();
    if (requiredUnfilledField) {
      new import_obsidian10.Notice(
        `Fill in the ${requiredUnfilledField.name} field before submitting`
      );
      return;
    }
    let anyInvalidInputExpression = false;
    const formInputExpressions = this.getInputExpressions();
    const filePathMatcher = new RegExp(`%%.*%%`);
    formInputExpressions.forEach((inputExpression) => {
      inputExpression.expression = inputExpression.expression.replace(
        filePathMatcher,
        "[]"
      );
      if (!isInputExpressionSyntaxValid(inputExpression.expression)) {
        new import_obsidian10.Notice(`Syntax error on ${inputExpression.fieldName}`);
        anyInvalidInputExpression = true;
      }
    });
    if (anyInvalidInputExpression)
      return;
    this.onSubmit(this.getData());
    this.close();
  }
  getInputExpressions() {
    const inputExpressions = [];
    this.formFieldFactories.forEach(({ formField }) => {
      var _a;
      if (!formField.content.value)
        return;
      const expressionMatcher = new RegExp(/{{(.*)}}/);
      const expressionToEvaluate = (_a = expressionMatcher.exec(formField.content.value)) == null ? void 0 : _a.at(-1);
      if (expressionToEvaluate)
        inputExpressions.push({
          fieldName: formField.name,
          expression: expressionToEvaluate
        });
    });
    return inputExpressions;
  }
  getRequiredUnfilledField() {
    const requiredFields = this.formFieldFactories.filter((factory) => factory.formField.required).map((factory) => factory.formField);
    return requiredFields.find((field) => {
      var _a;
      return !((_a = field.content.value) == null ? void 0 : _a.trim());
    });
  }
};

// src/settings/settings-tab.ts
var import_obsidian14 = require("obsidian");

// src/settings/handle-form-modal.ts
var import_obsidian13 = require("obsidian");

// src/settings/confirmation-modal.ts
var import_obsidian11 = require("obsidian");
var ConfirmationModal = class extends import_obsidian11.Modal {
  constructor(params) {
    super(params.app);
    this.submitLabel = params.submitLabel;
    this.title = params.title;
    this.description = params.description;
    this.onSubmit = params.onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.title });
    new import_obsidian11.Setting(contentEl).setDesc(this.description);
    new import_obsidian11.Setting(this.contentEl).addButton(
      (btn) => btn.setButtonText("Cancel").onClick(() => this.close())
    ).addButton(
      (btn) => btn.setButtonText(this.submitLabel).setWarning().onClick(() => {
        this.onSubmit();
        this.close();
      })
    );
  }
};

// src/settings/update-class-name-modal.ts
var import_obsidian12 = require("obsidian");
var UpdateClassNameModal = class extends import_obsidian12.Modal {
  constructor(app, currentClassName, existingClassNames, onSubmit) {
    super(app);
    this.currentClassName = currentClassName;
    this.onSubmit = onSubmit;
    this.existingClassNames = existingClassNames;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Update field class name" });
    contentEl.createEl("p", {
      text: "Will not update references to current class name in other fields expressions"
    });
    let inputValue = this.currentClassName;
    new import_obsidian12.Setting(contentEl).setName("Class name").setDesc("Non-alphanumeric characters will be replaced by '-'").addText((txt) => {
      txt.setValue(this.currentClassName).onChange(
        (value) => inputValue = value
      );
    });
    new import_obsidian12.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Update").setCta().onClick(() => {
        if (inputValue !== this.currentClassName) {
          inputValue = inputValue.toLowerCase().replace(/[^a-z0-9]/g, "-");
          if (this.existingClassNames.includes(inputValue)) {
            new import_obsidian12.Notice(
              `Class name "${inputValue}" already exists`
            );
            return;
          }
          this.onSubmit(inputValue);
        }
        this.close();
      })
    );
  }
};

// src/settings/handle-form-modal.constants.ts
var handleFormField = () => [
  {
    type: "dropdown" /* DROPDOWN */,
    name: "Type",
    className: "field-type",
    content: { value: void 0 },
    options: { value: Object.values(FORM_FIELD_ELEMENT_TYPE) }
  },
  {
    type: "text" /* TEXT */,
    name: "Name",
    description: { value: "Enter the field name" },
    className: "field-name",
    required: true,
    content: { value: void 0 }
  },
  {
    type: "text" /* TEXT */,
    name: "Class name",
    description: { value: "Field identifier" },
    className: "field-class-name",
    disable: true,
    content: {
      value: void 0,
      expressionParams: {
        expression: "{{$$.field-name.toLowerCase().replace(/[^a-z0-9]/g, '-')}}"
      }
    }
  },
  {
    type: "textarea" /* TEXTAREA */,
    name: "Description *",
    description: { value: "Optional - Enter field description" },
    className: "field-description",
    content: { value: void 0 },
    bypassValueExpressionEvaluation: true
  },
  {
    type: "textarea" /* TEXTAREA */,
    name: "Placeholder *",
    hideExpression: {
      value: void 0,
      expressionParams: {
        expression: "{{['dropdown','range'].includes($$.field-type)}}"
      }
    },
    description: { value: "Optional - Enter field placeholder" },
    className: "field-placeholder",
    bypassValueExpressionEvaluation: true,
    content: { value: void 0 }
  },
  {
    type: "textarea" /* TEXTAREA */,
    name: "Hide Expression *",
    description: {
      value: "Optional - Enter expression to hide field if true"
    },
    className: "field-hide-expression",
    bypassValueExpressionEvaluation: true,
    placeholder: { value: "false" },
    content: { value: void 0 }
  },
  {
    type: "toggle" /* TOGGLE */,
    name: "Required",
    description: {
      value: "If enabled, the field will be required to submit the form"
    },
    className: "field-required",
    hideExpression: {
      value: void 0,
      expressionParams: {
        expression: "{{['toggle','range'].includes($$.field-type)}}"
      }
    },
    content: {
      value: void 0,
      expressionParams: {
        expression: "{{['toggle','range'].includes($$.field-type) ? 'false' : 'true' }}"
      }
    }
  },
  {
    type: "textarea" /* TEXTAREA */,
    name: "Min *",
    description: { value: "Enter the range min value" },
    placeholder: { value: "1" },
    className: "field-min",
    hideExpression: {
      value: void 0,
      expressionParams: { expression: "{{$$.field-type !== 'range'}}" }
    },
    content: { value: void 0 },
    bypassValueExpressionEvaluation: true
  },
  {
    type: "textarea" /* TEXTAREA */,
    name: "Max *",
    description: { value: "Enter the range max value" },
    placeholder: { value: "10" },
    className: "field-max",
    hideExpression: {
      value: void 0,
      expressionParams: { expression: "{{$$.field-type !== 'range'}}" }
    },
    content: { value: void 0 },
    bypassValueExpressionEvaluation: true
  },
  {
    type: "textarea" /* TEXTAREA */,
    name: "Step *",
    description: { value: "Steps in which the slider will vary" },
    className: "field-step",
    hideExpression: {
      value: void 0,
      expressionParams: { expression: "{{$$.field-type !== 'range'}}" }
    },
    content: { value: void 0, expressionParams: { expression: "1" } },
    bypassValueExpressionEvaluation: true
  },
  {
    type: "textarea" /* TEXTAREA */,
    name: "Value *",
    description: {
      value: "Optional - Enter the default value of the field"
    },
    className: "field-default-value",
    placeholder: {
      value: void 0,
      expressionParams: {
        expression: `{{switch($$.field-type) {case 'number': return 10;case 'date': return 'DD/MM/YYYY';case 'time': return 'HH:mm';case 'dropdown': return "'itemA'";case 'toggle': return "true";default: return '';}}}`
      }
    },
    bypassValueExpressionEvaluation: true,
    content: { value: void 0 }
  },
  {
    type: "textarea" /* TEXTAREA */,
    name: "Options *",
    description: {
      value: "Enter the dropdown options as a array"
    },
    placeholder: { value: "['itemA', 'itemB']" },
    className: "field-dropdown-options",
    hideExpression: {
      value: void 0,
      expressionParams: {
        expression: "{{$$.field-type !== 'dropdown'}}"
      }
    },
    content: { value: void 0 }
  },
  {
    type: "toggle" /* TOGGLE */,
    name: "Write to Output Note",
    description: {
      value: "If enabled, the field value will be written to the output note"
    },
    className: "field-write-to-output-note",
    content: {
      value: void 0,
      expressionParams: { expression: "true" }
    }
  }
];

// src/settings/handle-form-modal.ts
var HandleFormModal = class extends import_obsidian13.Modal {
  constructor(params) {
    super(params.app);
    this.SUBMIT_CLASS = "submit-form-footer";
    this.FIELDS_SECTION = "fields-section";
    this.app = params.app;
    this.type = params.type;
    this.onSubmit = params.onSubmit;
    if (params.formData)
      this.form = params.formData;
    else {
      this.form = {};
      this.form["formFields"] = [];
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", {
      text: `${this.type} form`
    });
    new import_obsidian13.Setting(contentEl).setName("Form name").setDesc("Insert here the form name").addText(
      (txt) => {
        var _a;
        return txt.setValue((_a = this.form.title) != null ? _a : "").onChange((value) => this.form["title"] = value);
      }
    );
    new import_obsidian13.Setting(contentEl).setName("Form description").setDesc("Optional - Insert here the form description").addText(
      (txt) => {
        var _a;
        return txt.setValue((_a = this.form.description) != null ? _a : "").onChange((value) => this.form["description"] = value);
      }
    );
    new import_obsidian13.Setting(contentEl).setName("Output path").setDesc("Insert the path on your vault").addText(
      (txt) => {
        var _a;
        return txt.setValue((_a = this.form.path) != null ? _a : "").setPlaceholder("folder_inside_my_vault/").onChange((value) => this.form["path"] = value);
      }
    );
    new import_obsidian13.Setting(contentEl).setName("Output name *").setDesc("Optional - Output note name setting").addTextArea(
      (txt) => {
        var _a;
        return txt.setValue((_a = this.form.outputName) != null ? _a : "").onChange((value) => this.form["outputName"] = value);
      }
    );
    new import_obsidian13.Setting(contentEl).setName("Submit label").setDesc("Optional - Enter the button label for the submit button").addText(
      (txt) => {
        var _a;
        return txt.setValue((_a = this.form.submitLabel) != null ? _a : "").setPlaceholder("Submit").onChange((value) => this.form["submitLabel"] = value);
      }
    );
    new import_obsidian13.Setting(this.contentEl).setName("Show ribbon icon").setDesc("Add a ribbon icon to open this form").addToggle(
      (toggle) => {
        var _a, _b;
        return toggle.setValue((_b = (_a = this.form) == null ? void 0 : _a.showRibbonIcon) != null ? _b : false).onChange((value) => {
          this.form.showRibbonIcon = value;
        });
      }
    );
    new import_obsidian13.Setting(this.contentEl).setName("Ribbon icon name").setDesc("Name of the icon to use for the ribbon").addText(
      (text) => {
        var _a, _b;
        return text.setValue((_b = (_a = this.form) == null ? void 0 : _a.ribbonIconName) != null ? _b : "").onChange((value) => {
          this.form.ribbonIconName = value;
        });
      }
    );
    contentEl.createEl("h3", { text: "Fields" });
    this.refreshFieldsSection();
  }
  removeSubmitSection() {
    const submitFooterEl = this.contentEl.querySelector(
      `div.${this.SUBMIT_CLASS}`
    );
    const submitWarnEl = this.contentEl.querySelector(
      `div.${this.SUBMIT_CLASS}-warn`
    );
    submitFooterEl == null ? void 0 : submitFooterEl.remove();
    submitWarnEl == null ? void 0 : submitWarnEl.remove();
  }
  appendSubmitSection() {
    const isDisabled = !this.form.formFields.length;
    if (isDisabled)
      new import_obsidian13.Setting(this.contentEl).setClass(`${this.SUBMIT_CLASS}-warn`).setDesc("Add some field to create a form");
    const formParams = {
      formFields: handleFormField(),
      title: `Create new field`,
      description: "Fields with * can use expressions.",
      onSubmit: this.addNewField.bind(this),
      submitLabel: `Create`,
      path: ""
    };
    new import_obsidian13.Setting(this.contentEl).setClass(this.SUBMIT_CLASS).addButton(
      (btn) => btn.setButtonText("Add new field").onClick(() => {
        const form = new Form(this.app, formParams);
        form.open();
      })
    ).addButton(
      (btn) => btn.setButtonText(`${this.type} form`).setCta().setDisabled(isDisabled).onClick(this.handleSubmit.bind(this))
    );
  }
  handleFormFieldUpdate(fieldClassName) {
    const formFieldToUpdate = this.form.formFields.find(
      (formField) => formField.className === fieldClassName
    );
    if (formFieldToUpdate) {
      const formParams = {
        formFields: this.getUpdateForm(formFieldToUpdate),
        title: "Update field",
        path: "",
        description: "Fields with * can use expressions.",
        onSubmit: this.updateField.bind(this),
        submitLabel: "Update"
      };
      new Form(this.app, formParams).open();
    }
  }
  handleSubmit() {
    const duplicatedClassName = this.getDuplicatedClassName();
    if (duplicatedClassName) {
      new import_obsidian13.Notice(
        `Can't create form. Class name (${duplicatedClassName}) is not unique`
      );
      return;
    }
    const requiredUnfilled = this.getRequiredUnfilledField();
    if (requiredUnfilled) {
      new import_obsidian13.Notice(
        `Fill in the ${requiredUnfilled} field before submitting`
      );
      return;
    }
    const [_, outputNameExpression, __] = this.form.outputName ? ExpressionEvaluator.splitExpression(this.form.outputName) : ["", "", ""];
    if (outputNameExpression) {
      const isSyntaxValid = isInputExpressionSyntaxValid(outputNameExpression);
      if (!isSyntaxValid) {
        new import_obsidian13.Notice("Syntax error on output name field");
        return;
      }
    }
    this.postProcessParams();
    this.onSubmit(this.form);
    this.close();
  }
  addNewField(field) {
    const formField = fromFormDataToFormField(field);
    const formFieldsWithSameClassName = this.form.formFields.filter((f) => {
      const regex = new RegExp(`^${formField.className}(?:-\\d+)?$`);
      return regex.test(f.className);
    });
    if (formFieldsWithSameClassName.length)
      formField.className = `${formField.className}-${formFieldsWithSameClassName.length + 1}`;
    this.form.formFields.push(formField);
    this.refreshFieldsSection();
  }
  updateField(field) {
    const updatedFormField = fromFormDataToFormField(field);
    this.form.formFields.forEach((formField) => {
      if (formField.className === updatedFormField.className)
        formField = Object.assign(formField, updatedFormField);
    });
    this.refreshFieldsSection();
  }
  getDeleteFieldCallback(className) {
    return () => {
      this.form.formFields = this.form.formFields.filter(
        (formField) => formField.className !== className
      );
      this.refreshFieldsSection();
    };
  }
  refreshFieldsSection() {
    this.removeSubmitSection();
    this.removeFieldsSection();
    this.form.formFields.forEach((formField, idx) => {
      const setting = new import_obsidian13.Setting(this.contentEl).setName(formField.name).setClass(this.FIELDS_SECTION).setDesc(`${formField.type} - ${formField.className}`);
      if (idx > 0)
        setting.addExtraButton(
          (btn) => btn.setIcon("arrow-up").setTooltip("Move up").onClick(() => {
            const arr = this.form.formFields;
            [arr[idx - 1], arr[idx]] = [arr[idx], arr[idx - 1]];
            this.refreshFieldsSection();
          })
        );
      if (idx < this.form.formFields.length - 1)
        setting.addExtraButton(
          (btn) => btn.setIcon("arrow-down").setTooltip("Move down").onClick(() => {
            const arr = this.form.formFields;
            [arr[idx], arr[idx + 1]] = [arr[idx + 1], arr[idx]];
            this.refreshFieldsSection();
          })
        );
      setting.addExtraButton(
        (btn) => btn.setIcon("fingerprint").setTooltip("Edit class name").onClick(() => {
          new UpdateClassNameModal(
            this.app,
            formField.className,
            this.form.formFields.map((f) => f.className),
            (newClassName) => {
              formField.className = newClassName;
              this.refreshFieldsSection();
            }
          ).open();
        })
      );
      setting.addExtraButton(
        (btn) => btn.setIcon("pencil").setTooltip("Edit field").onClick(
          () => this.handleFormFieldUpdate.bind(this)(
            formField.className
          )
        )
      );
      setting.addExtraButton(
        (btn) => btn.setIcon("trash-2").setTooltip("Delete field").onClick(() => {
          const confirmationModal = new ConfirmationModal({
            app: this.app,
            description: `Are you sure you want to delete the ${formField.name} field?`,
            onSubmit: this.getDeleteFieldCallback(
              formField.className
            ).bind(this),
            submitLabel: "Delete",
            title: "Are you sure?"
          });
          confirmationModal.open();
        })
      );
    });
    this.appendSubmitSection();
  }
  removeFieldsSection() {
    const fieldEls = this.contentEl.querySelectorAll(
      `.${this.FIELDS_SECTION}`
    );
    fieldEls.forEach((fieldEl) => fieldEl == null ? void 0 : fieldEl.remove());
  }
  getDuplicatedClassName() {
    const uniqueClassNames = [];
    for (const field of this.form.formFields) {
      if (uniqueClassNames.includes(field.className))
        return field.className;
      else
        uniqueClassNames.push(field.className);
    }
    return;
  }
  getUpdateForm(formField) {
    const updateForm = handleFormField();
    updateForm.map((field) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
      let valueToAssign = void 0;
      switch (field.className) {
        case "field-type":
          valueToAssign = formField.type;
          break;
        case "field-name":
          valueToAssign = formField.name;
          break;
        case "field-class-name":
          valueToAssign = formField.className;
          break;
        case "field-description":
          valueToAssign = (_b = (_a = formField.description) == null ? void 0 : _a.expressionParams) == null ? void 0 : _b.expression;
          break;
        case "field-placeholder":
          valueToAssign = (_d = (_c = formField.placeholder) == null ? void 0 : _c.expressionParams) == null ? void 0 : _d.expression;
          break;
        case "field-hide-expression":
          valueToAssign = (_f = (_e = formField.hideExpression) == null ? void 0 : _e.expressionParams) == null ? void 0 : _f.expression;
          break;
        case "field-required":
          valueToAssign = `${formField.required}`;
          break;
        case "field-default-value":
          valueToAssign = (_h = (_g = formField.content) == null ? void 0 : _g.expressionParams) == null ? void 0 : _h.expression;
          break;
        case "field-write-to-output-note":
          valueToAssign = `${(_i = formField.writeToOutputNote) != null ? _i : true}`;
          break;
        case "field-dropdown-options":
          field.bypassValueExpressionEvaluation = true;
          valueToAssign = (_k = (_j = formField == null ? void 0 : formField.options) == null ? void 0 : _j.expressionParams) == null ? void 0 : _k.expression;
          break;
        case "field-min":
          valueToAssign = (_m = (_l = formField.minLimit) == null ? void 0 : _l.expressionParams) == null ? void 0 : _m.expression;
          break;
        case "field-max":
          valueToAssign = (_o = (_n = formField.maxLimit) == null ? void 0 : _n.expressionParams) == null ? void 0 : _o.expression;
          break;
        case "field-step":
          valueToAssign = (_q = (_p = formField.step) == null ? void 0 : _p.expressionParams) == null ? void 0 : _q.expression;
          break;
      }
      field.content = {
        value: void 0,
        expressionParams: { expression: valueToAssign }
      };
    });
    return updateForm;
  }
  getRequiredUnfilledField() {
    if (!this.form.title)
      return "Form name";
    if (!this.form.path)
      return "Path";
    return;
  }
  postProcessParams() {
    this.form.path = this.form.path.endsWith("/") ? this.form.path : `${this.form.path}/`;
    this.form.path = this.form.path.startsWith("/") ? this.form.path.split("").splice(1).join("") : this.form.path;
  }
};

// src/settings/settings-tab.ts
var mySettingsTab = class extends import_obsidian14.PluginSettingTab {
  constructor(plugin) {
    super(plugin.app, plugin);
    this.FORM_LIST_ITEM_CLASS = "form-list-item";
    this.plugin = plugin;
    this.plugin.loadSettings();
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian14.Setting(containerEl).setName("Create new form").setDesc("Click here to create a new form").addButton(
      (btn) => btn.setButtonText("Create form").onClick(
        () => new HandleFormModal({
          app: this.app,
          onSubmit: this.onCreateFormSubmit.bind(this),
          type: "Create"
        }).open()
      )
    );
    this.renderFormList();
  }
  async onCreateFormSubmit(createdForm) {
    var _a, _b;
    const formId = `${(_a = createdForm.title) == null ? void 0 : _a.replace(/\s/gm, "-")}-${new Date().getTime().toString(36)}`;
    const createdFormBo = {
      id: formId,
      active: true,
      ...createdForm
    };
    this.plugin.settings.forms = ((_b = this.plugin.settings.forms) == null ? void 0 : _b.length) ? [createdFormBo, ...this.plugin.settings.forms] : [createdFormBo];
    await this.plugin.saveSettings();
    this.renderFormList();
  }
  renderFormList() {
    var _a;
    this.removeFieldsSection();
    if ((_a = this.plugin.settings.forms) == null ? void 0 : _a.length) {
      this.containerEl.createEl("h2", {
        text: "Forms",
        cls: this.FORM_LIST_ITEM_CLASS
      });
      this.plugin.settings.forms.forEach((f) => {
        var _a2;
        delete f.ribbonRef;
        const form = structuredClone(f);
        this.createFormItemList(form);
        if (form.active)
          this.plugin.addCommandForm(form);
        if ((_a2 = form.ribbonRef) == null ? void 0 : _a2.remove)
          form.ribbonRef.remove();
        if (form.showRibbonIcon)
          this.plugin.addRibbonForm(form);
      });
    }
  }
  createFormItemList(form) {
    new import_obsidian14.Setting(this.containerEl).setName(form.title).setDesc(form.path).setClass(this.FORM_LIST_ITEM_CLASS).addExtraButton(
      (extraButton) => extraButton.setIcon("gear").onClick(() => {
        const updateForm = new HandleFormModal({
          app: this.app,
          onSubmit: this.getUpdateFormCallback(form.id).bind(
            this
          ),
          formData: form,
          type: "Update"
        });
        updateForm.open();
      })
    ).addExtraButton(
      (extraButton) => extraButton.setIcon("trash-2").onClick(() => {
        const confirmationModal = new ConfirmationModal({
          app: this.app,
          title: "Are you sure?",
          description: `Are you sure you want to delete the ${form.title} form?`,
          onSubmit: this.getDeleteFormCallback(form).bind(this),
          submitLabel: "Delete"
        });
        confirmationModal.open();
      })
    ).addToggle((toggle) => {
      toggle.setValue(form.active).onChange(this.getToggleFormActiveCallback(form.id));
    });
  }
  getUpdateFormCallback(formId) {
    return async (updatedForm) => {
      this.plugin.settings.forms = this.plugin.settings.forms.map(
        (form) => {
          if (form.id === formId) {
            form = Object.assign(form, updatedForm);
          }
          return form;
        }
      );
      await this.plugin.saveSettings();
      this.renderFormList();
    };
  }
  getToggleFormActiveCallback(formId) {
    return () => {
      const formToToggle = this.plugin.settings.forms.find(
        (form) => form.id === formId
      );
      if (formToToggle)
        formToToggle.active = !(formToToggle == null ? void 0 : formToToggle.active);
      this.plugin.saveSettings();
      this.renderFormList();
    };
  }
  getDeleteFormCallback(form) {
    return () => {
      var _a;
      this.plugin.settings.forms = this.plugin.settings.forms.filter(
        (f) => f.id !== form.id
      );
      if ((_a = form.ribbonRef) == null ? void 0 : _a.remove)
        form.ribbonRef.remove();
      if (form.active)
        new import_obsidian14.Notice("Reload plugin to fully remove form");
      this.plugin.saveSettings();
      this.renderFormList();
    };
  }
  removeFieldsSection() {
    const fieldEls = this.containerEl.querySelectorAll(
      `.${this.FORM_LIST_ITEM_CLASS}`
    );
    fieldEls == null ? void 0 : fieldEls.forEach((fieldEl) => fieldEl == null ? void 0 : fieldEl.remove());
  }
};

// main.ts
var MyPlugin = class extends import_obsidian15.Plugin {
  async onload() {
    await this.saveSettings();
    await this.loadSettings();
    this.addSettingTab(new mySettingsTab(this));
    this.activateForms();
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  activateForms() {
    var _a;
    (_a = this.settings.forms) == null ? void 0 : _a.forEach((form) => {
      if (form.active)
        this.addCommandForm(form);
      if (form.showRibbonIcon)
        this.addRibbonForm(form);
    });
  }
  addCommandForm(form) {
    this.addCommand({
      id: form.id,
      name: form.title,
      callback: () => {
        new Form(this.app, form).open();
      }
    });
  }
  addRibbonForm(form) {
    var _a, _b;
    if ((_a = form.ribbonRef) == null ? void 0 : _a.remove)
      form.ribbonRef.remove();
    form.ribbonRef = this.addRibbonIcon(
      (_b = form.ribbonIconName) != null ? _b : "circle",
      form.title,
      (_) => new Form(this.app, form).open()
    );
  }
};
